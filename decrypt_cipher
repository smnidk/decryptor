from sympy import mod_inverse, sqrt_mod

def modular_sqrt(a, p):
    """–ù–∞—Ö–æ–¥–∏—Ç –∫–æ—Ä–µ–Ω—å a –ø–æ –º–æ–¥—É–ª—é p, –µ—Å–ª–∏ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç."""
    if pow(a, (p - 1) // 2, p) != 1:
        return None  
    return sqrt_mod(a, p, all_roots=True)

def decrypt_affine_quadratic(encrypted_text, a, b, c, m):
    decrypted_text = ""

    for y in encrypted_text:
        D = (b**2 - 4*a*(c - y)) % m  
        sqrt_D = modular_sqrt(D, m)  

        if sqrt_D is None:
            continue  

        possible_x = set()  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–Ω–æ–∂–µ—Å—Ç–≤–æ, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø–æ–≤—Ç–æ—Ä–æ–≤
        for sqrt_val in sqrt_D:
            try:
                inv = mod_inverse(2 * a, m)
                x1 = ((-b + sqrt_val) * inv) % m
                x2 = ((-b - sqrt_val) * inv) % m
                possible_x.update([x1, x2])
            except ValueError:
                continue  # –ï—Å–ª–∏ –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º

        for x in possible_x:
            if 32 <= x <= 126:  # ASCII-—Å–∏–º–≤–æ–ª—ã (–≤–∏–¥–∏–º—ã–µ)
                decrypted_text += chr(x)

    return decrypted_text


# üîπ –ü—Ä–∏–º–µ—Ä –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
encrypted_data = [175, 97, 126, 236, 126, 244, 97, 94, 63]
a, b, c, m = 1, 2, 3, 257

decrypted_message = decrypt_affine_quadratic(encrypted_data, a, b, c, m)
print("–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç:", decrypted_message)
